{"version":3,"file":"KeyringController.js","sourceRoot":"","sources":["../src/KeyringController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { TxData, TypedTransaction } from '@ethereumjs/tx';\nimport { isValidPrivate, toBuffer, getBinarySize } from '@ethereumjs/util';\nimport type {\n  MetaMaskKeyring as QRKeyring,\n  IKeyringState as IQRKeyringState,\n} from '@keystonehq/metamask-airgapped-keyring';\nimport type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport * as encryptorUtils from '@metamask/browser-passworder';\nimport HDKeyring from '@metamask/eth-hd-keyring';\nimport { normalize } from '@metamask/eth-sig-util';\nimport SimpleKeyring from '@metamask/eth-simple-keyring';\nimport type {\n  EthBaseTransaction,\n  EthBaseUserOperation,\n  EthKeyring,\n  EthUserOperation,\n  EthUserOperationPatch,\n} from '@metamask/keyring-api';\nimport type {\n  PersonalMessageParams,\n  TypedMessageParams,\n} from '@metamask/message-manager';\nimport type {\n  Eip1024EncryptedData,\n  Hex,\n  Json,\n  KeyringClass,\n} from '@metamask/utils';\nimport {\n  add0x,\n  assertIsStrictHexString,\n  bytesToHex,\n  hasProperty,\n  isObject,\n  isValidHexAddress,\n  isValidJson,\n  remove0x,\n} from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport Wallet, { thirdparty as importers } from 'ethereumjs-wallet';\nimport type { Patch } from 'immer';\n\nimport { KeyringControllerError } from './constants';\n\nconst name = 'KeyringController';\n\n/**\n * Available keyring types\n */\nexport enum KeyringTypes {\n  simple = 'Simple Key Pair',\n  hd = 'HD Key Tree',\n  qr = 'QR Hardware Wallet Device',\n  trezor = 'Trezor Hardware',\n  ledger = 'Ledger Hardware',\n  lattice = 'Lattice Hardware',\n  snap = 'Snap Keyring',\n}\n\n/**\n * Custody keyring types are a special case, as they are not a single type\n * but they all start with the prefix \"Custody\".\n * @param keyringType - The type of the keyring.\n * @returns Whether the keyring type is a custody keyring.\n */\nexport const isCustodyKeyring = (keyringType: string): boolean => {\n  return keyringType.startsWith('Custody');\n};\n\n/**\n * @type KeyringControllerState\n *\n * Keyring controller state\n * @property vault - Encrypted string representing keyring data\n * @property isUnlocked - Whether vault is unlocked\n * @property keyringTypes - Account types\n * @property keyrings - Group of accounts\n * @property encryptionKey - Keyring encryption key\n * @property encryptionSalt - Keyring encryption salt\n */\nexport type KeyringControllerState = {\n  vault?: string;\n  isUnlocked: boolean;\n  keyrings: KeyringObject[];\n  encryptionKey?: string;\n  encryptionSalt?: string;\n};\n\nexport type KeyringControllerMemState = Omit<\n  KeyringControllerState,\n  'vault' | 'encryptionKey' | 'encryptionSalt'\n>;\n\nexport type KeyringControllerGetStateAction = {\n  type: `${typeof name}:getState`;\n  handler: () => KeyringControllerState;\n};\n\nexport type KeyringControllerSignMessageAction = {\n  type: `${typeof name}:signMessage`;\n  handler: KeyringController['signMessage'];\n};\n\nexport type KeyringControllerSignPersonalMessageAction = {\n  type: `${typeof name}:signPersonalMessage`;\n  handler: KeyringController['signPersonalMessage'];\n};\n\nexport type KeyringControllerSignTypedMessageAction = {\n  type: `${typeof name}:signTypedMessage`;\n  handler: KeyringController['signTypedMessage'];\n};\n\nexport type KeyringControllerDecryptMessageAction = {\n  type: `${typeof name}:decryptMessage`;\n  handler: KeyringController['decryptMessage'];\n};\n\nexport type KeyringControllerGetEncryptionPublicKeyAction = {\n  type: `${typeof name}:getEncryptionPublicKey`;\n  handler: KeyringController['getEncryptionPublicKey'];\n};\n\nexport type KeyringControllerGetKeyringsByTypeAction = {\n  type: `${typeof name}:getKeyringsByType`;\n  handler: KeyringController['getKeyringsByType'];\n};\n\nexport type KeyringControllerGetKeyringForAccountAction = {\n  type: `${typeof name}:getKeyringForAccount`;\n  handler: KeyringController['getKeyringForAccount'];\n};\n\nexport type KeyringControllerGetAccountsAction = {\n  type: `${typeof name}:getAccounts`;\n  handler: KeyringController['getAccounts'];\n};\n\nexport type KeyringControllerPersistAllKeyringsAction = {\n  type: `${typeof name}:persistAllKeyrings`;\n  handler: KeyringController['persistAllKeyrings'];\n};\n\nexport type KeyringControllerPrepareUserOperationAction = {\n  type: `${typeof name}:prepareUserOperation`;\n  handler: KeyringController['prepareUserOperation'];\n};\n\nexport type KeyringControllerPatchUserOperationAction = {\n  type: `${typeof name}:patchUserOperation`;\n  handler: KeyringController['patchUserOperation'];\n};\n\nexport type KeyringControllerSignUserOperationAction = {\n  type: `${typeof name}:signUserOperation`;\n  handler: KeyringController['signUserOperation'];\n};\n\nexport type KeyringControllerStateChangeEvent = {\n  type: `${typeof name}:stateChange`;\n  payload: [KeyringControllerState, Patch[]];\n};\n\nexport type KeyringControllerAccountRemovedEvent = {\n  type: `${typeof name}:accountRemoved`;\n  payload: [string];\n};\n\nexport type KeyringControllerLockEvent = {\n  type: `${typeof name}:lock`;\n  payload: [];\n};\n\nexport type KeyringControllerUnlockEvent = {\n  type: `${typeof name}:unlock`;\n  payload: [];\n};\n\nexport type KeyringControllerQRKeyringStateChangeEvent = {\n  type: `${typeof name}:qrKeyringStateChange`;\n  payload: [ReturnType<IQRKeyringState['getState']>];\n};\n\nexport type KeyringControllerActions =\n  | KeyringControllerGetStateAction\n  | KeyringControllerSignMessageAction\n  | KeyringControllerSignPersonalMessageAction\n  | KeyringControllerSignTypedMessageAction\n  | KeyringControllerDecryptMessageAction\n  | KeyringControllerGetEncryptionPublicKeyAction\n  | KeyringControllerGetAccountsAction\n  | KeyringControllerGetKeyringsByTypeAction\n  | KeyringControllerGetKeyringForAccountAction\n  | KeyringControllerPersistAllKeyringsAction\n  | KeyringControllerPrepareUserOperationAction\n  | KeyringControllerPatchUserOperationAction\n  | KeyringControllerSignUserOperationAction;\n\nexport type KeyringControllerEvents =\n  | KeyringControllerStateChangeEvent\n  | KeyringControllerLockEvent\n  | KeyringControllerUnlockEvent\n  | KeyringControllerAccountRemovedEvent\n  | KeyringControllerQRKeyringStateChangeEvent;\n\nexport type KeyringControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  KeyringControllerActions,\n  KeyringControllerEvents,\n  string,\n  string\n>;\n\nexport type KeyringControllerOptions = {\n  keyringBuilders?: { (): EthKeyring<Json>; type: string }[];\n  messenger: KeyringControllerMessenger;\n  state?: { vault?: string };\n} & (\n  | {\n      cacheEncryptionKey: true;\n      encryptor?: ExportableKeyEncryptor;\n    }\n  | {\n      cacheEncryptionKey?: false;\n      encryptor?: GenericEncryptor | ExportableKeyEncryptor;\n    }\n);\n\n/**\n * @type KeyringObject\n *\n * Keyring object to return in fullUpdate\n * @property type - Keyring type\n * @property accounts - Associated accounts\n */\nexport type KeyringObject = {\n  accounts: string[];\n  type: string;\n};\n\n/**\n * A strategy for importing an account\n */\nexport enum AccountImportStrategy {\n  privateKey = 'privateKey',\n  json = 'json',\n}\n\n/**\n * The `signTypedMessage` version\n *\n * @see https://docs.metamask.io/guide/signing-data.html\n */\nexport enum SignTypedDataVersion {\n  V1 = 'V1',\n  V3 = 'V3',\n  V4 = 'V4',\n}\n\n/**\n * A serialized keyring object.\n */\nexport type SerializedKeyring = {\n  type: string;\n  data: Json;\n};\n\n/**\n * A generic encryptor interface that supports encrypting and decrypting\n * serializable data with a password.\n */\nexport type GenericEncryptor = {\n  /**\n   * Encrypts the given object with the given password.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encrypted string.\n   */\n  encrypt: (password: string, object: Json) => Promise<string>;\n  /**\n   * Decrypts the given encrypted string with the given password.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decrypt: (password: string, encryptedString: string) => Promise<unknown>;\n  /**\n   * Optional vault migration helper. Checks if the provided vault is up to date\n   * with the desired encryption algorithm.\n   *\n   * @param vault - The encrypted string to check.\n   * @param targetDerivationParams - The desired target derivation params.\n   * @returns The updated encrypted string.\n   */\n  isVaultUpdated?: (\n    vault: string,\n    targetDerivationParams?: encryptorUtils.KeyDerivationOptions,\n  ) => boolean;\n};\n\n/**\n * An encryptor interface that supports encrypting and decrypting\n * serializable data with a password, and exporting and importing keys.\n */\nexport type ExportableKeyEncryptor = GenericEncryptor & {\n  /**\n   * Encrypts the given object with the given encryption key.\n   *\n   * @param key - The encryption key to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encryption result.\n   */\n  encryptWithKey: (\n    key: unknown,\n    object: Json,\n  ) => Promise<encryptorUtils.EncryptionResult>;\n  /**\n   * Encrypts the given object with the given password, and returns the\n   * encryption result and the exported key string.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @param salt - The optional salt to use for encryption.\n   * @returns The encrypted string and the exported key string.\n   */\n  encryptWithDetail: (\n    password: string,\n    object: Json,\n    salt?: string,\n  ) => Promise<encryptorUtils.DetailedEncryptionResult>;\n  /**\n   * Decrypts the given encrypted string with the given encryption key.\n   *\n   * @param key - The encryption key to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decryptWithKey: (key: unknown, encryptedString: string) => Promise<unknown>;\n  /**\n   * Decrypts the given encrypted string with the given password, and returns\n   * the decrypted object and the salt and exported key string used for\n   * encryption.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object and the salt and exported key string used for\n   * encryption.\n   */\n  decryptWithDetail: (\n    password: string,\n    encryptedString: string,\n  ) => Promise<encryptorUtils.DetailedDecryptResult>;\n  /**\n   * Generates an encryption key from exported key string.\n   *\n   * @param key - The exported key string.\n   * @returns The encryption key.\n   */\n  importKey: (key: string) => Promise<unknown>;\n};\n\n/**\n * Get builder function for `Keyring`\n *\n * Returns a builder function for `Keyring` with a `type` property.\n *\n * @param KeyringConstructor - The Keyring class for the builder.\n * @returns A builder function for the given Keyring.\n */\nexport function keyringBuilderFactory(KeyringConstructor: KeyringClass<Json>) {\n  const builder = () => new KeyringConstructor();\n\n  builder.type = KeyringConstructor.type;\n\n  return builder;\n}\n\nconst defaultKeyringBuilders = [\n  keyringBuilderFactory(SimpleKeyring),\n  keyringBuilderFactory(HDKeyring),\n];\n\nexport const getDefaultKeyringState = (): KeyringControllerState => {\n  return {\n    isUnlocked: false,\n    keyrings: [],\n  };\n};\n\n/**\n * Assert that the given keyring has an exportable\n * mnemonic.\n *\n * @param keyring - The keyring to check\n * @throws When the keyring does not have a mnemonic\n */\nfunction assertHasUint8ArrayMnemonic(\n  keyring: EthKeyring<Json>,\n): asserts keyring is EthKeyring<Json> & { mnemonic: Uint8Array } {\n  if (\n    !(\n      hasProperty(keyring, 'mnemonic') && keyring.mnemonic instanceof Uint8Array\n    )\n  ) {\n    throw new Error(\"Can't get mnemonic bytes from keyring\");\n  }\n}\n\n/**\n * Assert that the provided encryptor supports\n * encryption and encryption key export.\n *\n * @param encryptor - The encryptor to check.\n * @throws If the encryptor does not support key encryption.\n */\nfunction assertIsExportableKeyEncryptor(\n  encryptor: GenericEncryptor | ExportableKeyEncryptor,\n): asserts encryptor is ExportableKeyEncryptor {\n  if (\n    !(\n      'importKey' in encryptor &&\n      typeof encryptor.importKey === 'function' &&\n      'decryptWithKey' in encryptor &&\n      typeof encryptor.decryptWithKey === 'function' &&\n      'encryptWithKey' in encryptor &&\n      typeof encryptor.encryptWithKey === 'function'\n    )\n  ) {\n    throw new Error(KeyringControllerError.UnsupportedEncryptionKeyExport);\n  }\n}\n\n/**\n * Checks if the provided value is a serialized keyrings array.\n *\n * @param array - The value to check.\n * @returns True if the value is a serialized keyrings array.\n */\nfunction isSerializedKeyringsArray(\n  array: unknown,\n): array is SerializedKeyring[] {\n  return (\n    typeof array === 'object' &&\n    Array.isArray(array) &&\n    array.every((value) => value.type && isValidJson(value.data))\n  );\n}\n\n/**\n * Display For Keyring\n *\n * Is used for adding the current keyrings to the state object.\n *\n * @param keyring - The keyring to display.\n * @returns A keyring display object, with type and accounts properties.\n */\nasync function displayForKeyring(\n  keyring: EthKeyring<Json>,\n): Promise<{ type: string; accounts: string[] }> {\n  const accounts = await keyring.getAccounts();\n\n  return {\n    type: keyring.type,\n    // Cast to `Hex[]` here is safe here because `accounts` has no nullish\n    // values, and `normalize` returns `Hex` unless given a nullish value\n    accounts: accounts.map(normalize) as Hex[],\n  };\n}\n\n/**\n * Controller responsible for establishing and managing user identity.\n *\n * This class is a wrapper around the `eth-keyring-controller` package. The\n * `eth-keyring-controller` manages the \"vault\", which is an encrypted store of private keys, and\n * it manages the wallet \"lock\" state. This wrapper class has convenience methods for interacting\n * with the internal keyring controller and handling certain complex operations that involve the\n * keyrings.\n */\nexport class KeyringController extends BaseController<\n  typeof name,\n  KeyringControllerState,\n  KeyringControllerMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  #keyringBuilders: { (): EthKeyring<Json>; type: string }[];\n\n  #keyrings: EthKeyring<Json>[];\n\n  #unsupportedKeyrings: SerializedKeyring[];\n\n  #password?: string;\n\n  #encryptor: GenericEncryptor | ExportableKeyEncryptor;\n\n  #cacheEncryptionKey: boolean;\n\n  #qrKeyringStateListener?: (\n    state: ReturnType<IQRKeyringState['getState']>,\n  ) => void;\n\n  /**\n   * Creates a KeyringController instance.\n   *\n   * @param options - Initial options used to configure this controller\n   * @param options.encryptor - An optional object for defining encryption schemes.\n   * @param options.keyringBuilders - Set a new name for account.\n   * @param options.cacheEncryptionKey - Whether to cache or not encryption key.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   */\n  constructor(options: KeyringControllerOptions) {\n    const {\n      encryptor = encryptorUtils,\n      keyringBuilders,\n      messenger,\n      state,\n    } = options;\n\n    super({\n      name,\n      metadata: {\n        vault: { persist: true, anonymous: false },\n        isUnlocked: { persist: false, anonymous: true },\n        keyrings: { persist: false, anonymous: false },\n        encryptionKey: { persist: false, anonymous: false },\n        encryptionSalt: { persist: false, anonymous: false },\n      },\n      messenger,\n      state: {\n        ...getDefaultKeyringState(),\n        ...state,\n      },\n    });\n\n    this.#keyringBuilders = keyringBuilders\n      ? defaultKeyringBuilders.concat(keyringBuilders)\n      : defaultKeyringBuilders;\n\n    this.#encryptor = encryptor;\n    this.#keyrings = [];\n    this.#unsupportedKeyrings = [];\n\n    // This option allows the controller to cache an exported key\n    // for use in decrypting and encrypting data without password\n    this.#cacheEncryptionKey = Boolean(options.cacheEncryptionKey);\n    if (this.#cacheEncryptionKey) {\n      assertIsExportableKeyEncryptor(encryptor);\n    }\n\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring.\n   *\n   * @param accountCount - Number of accounts before adding a new one, used to\n   * make the method idempotent.\n   * @returns Promise resolving to keyring current state and added account\n   * address.\n   */\n  async addNewAccount(accountCount?: number): Promise<{\n    keyringState: KeyringControllerMemState;\n    addedAccountAddress: string;\n  }> {\n    const primaryKeyring = this.getKeyringsByType('HD Key Tree')[0] as\n      | EthKeyring<Json>\n      | undefined;\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found');\n    }\n    const oldAccounts = await this.getAccounts();\n\n    if (accountCount && oldAccounts.length !== accountCount) {\n      if (accountCount > oldAccounts.length) {\n        throw new Error('Account out of sequence');\n      }\n      // we return the account already existing at index `accountCount`\n      const primaryKeyringAccounts = await primaryKeyring.getAccounts();\n      return {\n        keyringState: this.#getMemState(),\n        addedAccountAddress: primaryKeyringAccounts[accountCount],\n      };\n    }\n\n    const addedAccountAddress = await this.addNewAccountForKeyring(\n      primaryKeyring,\n    );\n    await this.verifySeedPhrase();\n\n    return {\n      keyringState: this.#getMemState(),\n      addedAccountAddress,\n    };\n  }\n\n  /**\n   * Adds a new account to the specified keyring.\n   *\n   * @param keyring - Keyring to add the account to.\n   * @param accountCount - Number of accounts before adding a new one, used to make the method idempotent.\n   * @returns Promise resolving to keyring current state and added account\n   */\n  async addNewAccountForKeyring(\n    keyring: EthKeyring<Json>,\n    accountCount?: number,\n  ): Promise<Hex> {\n    const oldAccounts = await this.getAccounts();\n\n    if (accountCount && oldAccounts.length !== accountCount) {\n      if (accountCount > oldAccounts.length) {\n        throw new Error('Account out of sequence');\n      }\n\n      const existingAccount = oldAccounts[accountCount];\n      assertIsStrictHexString(existingAccount);\n\n      return existingAccount;\n    }\n\n    await keyring.addAccounts(1);\n    await this.persistAllKeyrings();\n\n    const addedAccountAddress = (await this.getAccounts()).find(\n      (selectedAddress) => !oldAccounts.includes(selectedAddress),\n    );\n    assertIsStrictHexString(addedAccountAddress);\n\n    return addedAccountAddress;\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.\n   *\n   * @returns Promise resolving to current state when the account is added.\n   */\n  async addNewAccountWithoutUpdate(): Promise<KeyringControllerMemState> {\n    const primaryKeyring = this.getKeyringsByType('HD Key Tree')[0] as\n      | EthKeyring<Json>\n      | undefined;\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found');\n    }\n    await primaryKeyring.addAccounts(1);\n    await this.persistAllKeyrings();\n    await this.verifySeedPhrase();\n    return this.#getMemState();\n  }\n\n  /**\n   * Effectively the same as creating a new keychain then populating it\n   * using the given seed phrase.\n   *\n   * @param password - Password to unlock keychain.\n   * @param seed - A BIP39-compliant seed phrase as Uint8Array,\n   * either as a string or an array of UTF-8 bytes that represent the string.\n   * @returns Promise resolving to the restored keychain object.\n   */\n  async createNewVaultAndRestore(\n    password: string,\n    seed: Uint8Array,\n  ): Promise<KeyringControllerMemState> {\n    const releaseLock = await this.mutex.acquire();\n    if (!password || !password.length) {\n      throw new Error('Invalid password');\n    }\n\n    try {\n      await this.#createNewVaultWithKeyring(password, {\n        type: KeyringTypes.hd,\n        opts: {\n          mnemonic: seed,\n          numberOfAccounts: 1,\n        },\n      });\n      return this.#getMemState();\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Create a new primary keychain and wipe any previous keychains.\n   *\n   * @param password - Password to unlock the new vault.\n   * @returns Newly-created keychain object.\n   */\n  async createNewVaultAndKeychain(password: string) {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const accounts = await this.getAccounts();\n      if (!accounts.length) {\n        await this.#createNewVaultWithKeyring(password, {\n          type: KeyringTypes.hd,\n        });\n      }\n      return this.#getMemState();\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds a new keyring of the given `type`.\n   *\n   * @param type - Keyring type name.\n   * @param opts - Keyring options.\n   * @throws If a builder for the given `type` does not exist.\n   * @returns Promise resolving to the added keyring.\n   */\n  async addNewKeyring(\n    type: KeyringTypes | string,\n    opts?: unknown,\n  ): Promise<unknown> {\n    if (type === KeyringTypes.qr) {\n      return this.getOrAddQRKeyring();\n    }\n\n    const keyring = await this.#newKeyring(type, opts);\n\n    if (type === KeyringTypes.hd && (!isObject(opts) || !opts.mnemonic)) {\n      if (!keyring.generateRandomMnemonic) {\n        throw new Error(\n          KeyringControllerError.UnsupportedGenerateRandomMnemonic,\n        );\n      }\n\n      keyring.generateRandomMnemonic();\n      await keyring.addAccounts(1);\n    }\n\n    const accounts = await keyring.getAccounts();\n    await this.#checkForDuplicate(type, accounts);\n\n    this.#keyrings.push(keyring);\n    await this.persistAllKeyrings();\n\n    return keyring;\n  }\n\n  /**\n   * Method to verify a given password validity. Throws an\n   * error if the password is invalid.\n   *\n   * @param password - Password of the keyring.\n   */\n  async verifyPassword(password: string) {\n    if (!this.state.vault) {\n      throw new Error(KeyringControllerError.VaultError);\n    }\n    await this.#encryptor.decrypt(password, this.state.vault);\n  }\n\n  /**\n   * Returns the status of the vault.\n   *\n   * @returns Boolean returning true if the vault is unlocked.\n   */\n  isUnlocked(): boolean {\n    return this.state.isUnlocked;\n  }\n\n  /**\n   * Gets the seed phrase of the HD keyring.\n   *\n   * @param password - Password of the keyring.\n   * @returns Promise resolving to the seed phrase.\n   */\n  async exportSeedPhrase(password: string): Promise<Uint8Array> {\n    await this.verifyPassword(password);\n    assertHasUint8ArrayMnemonic(this.#keyrings[0]);\n    return this.#keyrings[0].mnemonic;\n  }\n\n  /**\n   * Gets the private key from the keyring controlling an address.\n   *\n   * @param password - Password of the keyring.\n   * @param address - Address to export.\n   * @returns Promise resolving to the private key for an address.\n   */\n  async exportAccount(password: string, address: string): Promise<string> {\n    await this.verifyPassword(password);\n\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.exportAccount) {\n      throw new Error(KeyringControllerError.UnsupportedExportAccount);\n    }\n\n    return await keyring.exportAccount(normalize(address) as Hex);\n  }\n\n  /**\n   * Returns the public addresses of all accounts for the current keyring.\n   *\n   * @returns A promise resolving to an array of addresses.\n   */\n  async getAccounts(): Promise<string[]> {\n    const keyrings = this.#keyrings;\n\n    const keyringArrays = await Promise.all(\n      keyrings.map(async (keyring) => keyring.getAccounts()),\n    );\n    const addresses = keyringArrays.reduce((res, arr) => {\n      return res.concat(arr);\n    }, []);\n\n    // Cast to `Hex[]` here is safe here because `addresses` has no nullish\n    // values, and `normalize` returns `Hex` unless given a nullish value\n    return addresses.map(normalize) as Hex[];\n  }\n\n  /**\n   * Get encryption public key.\n   *\n   * @param account - An account address.\n   * @param opts - Additional encryption options.\n   * @throws If the `account` does not exist or does not support the `getEncryptionPublicKey` method\n   * @returns Promise resolving to encyption public key of the `account` if one exists.\n   */\n  async getEncryptionPublicKey(\n    account: string,\n    opts?: Record<string, unknown>,\n  ): Promise<string> {\n    const normalizedAddress = normalize(account) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      account,\n    )) as EthKeyring<Json>;\n    if (!keyring.getEncryptionPublicKey) {\n      throw new Error(KeyringControllerError.UnsupportedGetEncryptionPublicKey);\n    }\n\n    return await keyring.getEncryptionPublicKey(normalizedAddress, opts);\n  }\n\n  /**\n   * Attempts to decrypt the provided message parameters.\n   *\n   * @param messageParams - The decryption message parameters.\n   * @param messageParams.from - The address of the account you want to use to decrypt the message.\n   * @param messageParams.data - The encrypted data that you want to decrypt.\n   * @returns The raw decryption result.\n   */\n  async decryptMessage(messageParams: {\n    from: string;\n    data: Eip1024EncryptedData;\n  }): Promise<string> {\n    const address = normalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.decryptMessage) {\n      throw new Error(KeyringControllerError.UnsupportedDecryptMessage);\n    }\n\n    return keyring.decryptMessage(address, messageParams.data);\n  }\n\n  /**\n   * Returns the currently initialized keyring that manages\n   * the specified `address` if one exists.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault.\n   * @param account - An account address.\n   * @returns Promise resolving to keyring of the `account` if one exists.\n   */\n  async getKeyringForAccount(account: string): Promise<unknown> {\n    // Cast to `Hex` here is safe here because `address` is not nullish.\n    // `normalizeToHex` returns `Hex` unless given a nullish value.\n    const hexed = normalize(account) as Hex;\n\n    const candidates = await Promise.all(\n      this.#keyrings.map(async (keyring) => {\n        return Promise.all([keyring, keyring.getAccounts()]);\n      }),\n    );\n\n    const winners = candidates.filter((candidate) => {\n      const accounts = candidate[1].map(normalize);\n      return accounts.includes(hexed);\n    });\n\n    if (winners.length && winners[0]?.length) {\n      return winners[0][0];\n    }\n\n    // Adding more info to the error\n    let errorInfo = '';\n    if (!isValidHexAddress(hexed)) {\n      errorInfo = 'The address passed in is invalid/empty';\n    } else if (!candidates.length) {\n      errorInfo = 'There are no keyrings';\n    } else if (!winners.length) {\n      errorInfo = 'There are keyrings, but none match the address';\n    }\n    throw new Error(\n      `${KeyringControllerError.NoKeyring}. Error info: ${errorInfo}`,\n    );\n  }\n\n  /**\n   * Returns all keyrings of the given type.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault.\n   * @param type - Keyring type name.\n   * @returns An array of keyrings of the given type.\n   */\n  getKeyringsByType(type: KeyringTypes | string): unknown[] {\n    return this.#keyrings.filter((keyring) => keyring.type === type);\n  }\n\n  /**\n   * Persist all serialized keyrings in the vault.\n   *\n   * @returns Promise resolving with `true` value when the\n   * operation completes.\n   */\n  async persistAllKeyrings(): Promise<boolean> {\n    const { encryptionKey, encryptionSalt } = this.state;\n\n    if (!this.#password && !encryptionKey) {\n      throw new Error(KeyringControllerError.MissingCredentials);\n    }\n\n    const serializedKeyrings = await Promise.all(\n      this.#keyrings.map(async (keyring) => {\n        const [type, data] = await Promise.all([\n          keyring.type,\n          keyring.serialize(),\n        ]);\n        return { type, data };\n      }),\n    );\n\n    serializedKeyrings.push(...this.#unsupportedKeyrings);\n\n    let vault: string | undefined;\n    let newEncryptionKey: string | undefined;\n\n    if (this.#cacheEncryptionKey) {\n      assertIsExportableKeyEncryptor(this.#encryptor);\n\n      if (encryptionKey) {\n        const key = await this.#encryptor.importKey(encryptionKey);\n        const vaultJSON = await this.#encryptor.encryptWithKey(\n          key,\n          serializedKeyrings,\n        );\n        vaultJSON.salt = encryptionSalt;\n        vault = JSON.stringify(vaultJSON);\n      } else if (this.#password) {\n        const { vault: newVault, exportedKeyString } =\n          await this.#encryptor.encryptWithDetail(\n            this.#password,\n            serializedKeyrings,\n          );\n\n        vault = newVault;\n        newEncryptionKey = exportedKeyString;\n      }\n    } else {\n      if (typeof this.#password !== 'string') {\n        throw new TypeError(KeyringControllerError.WrongPasswordType);\n      }\n      vault = await this.#encryptor.encrypt(this.#password, serializedKeyrings);\n    }\n\n    if (!vault) {\n      throw new Error(KeyringControllerError.MissingVaultData);\n    }\n\n    this.update((state) => {\n      state.vault = vault;\n    });\n\n    // The keyring updates need to be announced before updating the encryptionKey\n    // so that the updated keyring gets propagated to the extension first.\n    // Not calling {@link updateKeyringsInState} results in the wrong account being selected\n    // in the extension.\n    await this.#updateKeyringsInState();\n    if (newEncryptionKey) {\n      this.update((state) => {\n        state.encryptionKey = newEncryptionKey;\n        state.encryptionSalt = JSON.parse(vault as string).salt;\n      });\n    }\n\n    return true;\n  }\n\n  /**\n   * Imports an account with the specified import strategy.\n   *\n   * @param strategy - Import strategy name.\n   * @param args - Array of arguments to pass to the underlying stategy.\n   * @throws Will throw when passed an unrecognized strategy.\n   * @returns Promise resolving to keyring current state and imported account\n   * address.\n   */\n  async importAccountWithStrategy(\n    strategy: AccountImportStrategy,\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    args: any[],\n  ): Promise<{\n    keyringState: KeyringControllerMemState;\n    importedAccountAddress: string;\n  }> {\n    let privateKey;\n    switch (strategy) {\n      case 'privateKey':\n        const [importedKey] = args;\n        if (!importedKey) {\n          throw new Error('Cannot import an empty key.');\n        }\n        const prefixed = add0x(importedKey);\n\n        let bufferedPrivateKey;\n        try {\n          bufferedPrivateKey = toBuffer(prefixed);\n        } catch {\n          throw new Error('Cannot import invalid private key.');\n        }\n\n        if (\n          !isValidPrivate(bufferedPrivateKey) ||\n          // ensures that the key is 64 bytes long\n          getBinarySize(prefixed) !== 64 + '0x'.length\n        ) {\n          throw new Error('Cannot import invalid private key.');\n        }\n\n        privateKey = remove0x(prefixed);\n        break;\n      case 'json':\n        let wallet;\n        const [input, password] = args;\n        try {\n          wallet = importers.fromEtherWallet(input, password);\n        } catch (e) {\n          wallet = wallet || (await Wallet.fromV3(input, password, true));\n        }\n        privateKey = bytesToHex(wallet.getPrivateKey());\n        break;\n      default:\n        throw new Error(`Unexpected import strategy: '${strategy}'`);\n    }\n    const newKeyring = (await this.addNewKeyring(KeyringTypes.simple, [\n      privateKey,\n    ])) as EthKeyring<Json>;\n    const accounts = await newKeyring.getAccounts();\n    return {\n      keyringState: this.#getMemState(),\n      importedAccountAddress: accounts[0],\n    };\n  }\n\n  /**\n   * Removes an account from keyring state.\n   *\n   * @param address - Address of the account to remove.\n   * @fires KeyringController:accountRemoved\n   * @returns Promise resolving current state when this account removal completes.\n   */\n  async removeAccount(address: Hex): Promise<KeyringControllerMemState> {\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    // Not all the keyrings support this, so we have to check\n    if (!keyring.removeAccount) {\n      throw new Error(KeyringControllerError.UnsupportedRemoveAccount);\n    }\n\n    // The `removeAccount` method of snaps keyring is async. We have to update\n    // the interface of the other keyrings to be async as well.\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    await keyring.removeAccount(address);\n\n    const accounts = await keyring.getAccounts();\n    // Check if this was the last/only account\n    if (accounts.length === 0) {\n      await this.#removeEmptyKeyrings();\n    }\n\n    await this.persistAllKeyrings();\n\n    this.messagingSystem.publish(`${name}:accountRemoved`, address);\n    return this.#getMemState();\n  }\n\n  /**\n   * Deallocates all secrets and locks the wallet.\n   *\n   * @returns Promise resolving to current state.\n   */\n  async setLocked(): Promise<KeyringControllerMemState> {\n    this.#unsubscribeFromQRKeyringsEvents();\n\n    this.#password = undefined;\n    this.update((state) => {\n      state.isUnlocked = false;\n      state.keyrings = [];\n    });\n    await this.#clearKeyrings();\n\n    this.messagingSystem.publish(`${name}:lock`);\n\n    return this.#getMemState();\n  }\n\n  /**\n   * Signs message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  async signMessage(messageParams: PersonalMessageParams): Promise<string> {\n    if (!messageParams.data) {\n      throw new Error(\"Can't sign an empty message\");\n    }\n\n    const address = normalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignMessage);\n    }\n\n    return await keyring.signMessage(address, messageParams.data);\n  }\n\n  /**\n   * Signs personal message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  async signPersonalMessage(messageParams: PersonalMessageParams) {\n    const address = normalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signPersonalMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignPersonalMessage);\n    }\n\n    const normalizedData = normalize(messageParams.data) as Hex;\n\n    return await keyring.signPersonalMessage(address, normalizedData);\n  }\n\n  /**\n   * Signs typed message by calling down into a specific keyring.\n   *\n   * @param messageParams - TypedMessageParams object to sign.\n   * @param version - Compatibility version EIP712.\n   * @throws Will throw when passed an unrecognized version.\n   * @returns Promise resolving to a signed message string or an error if any.\n   */\n  async signTypedMessage(\n    messageParams: TypedMessageParams,\n    version: SignTypedDataVersion,\n  ): Promise<string> {\n    try {\n      if (\n        ![\n          SignTypedDataVersion.V1,\n          SignTypedDataVersion.V3,\n          SignTypedDataVersion.V4,\n        ].includes(version)\n      ) {\n        throw new Error(`Unexpected signTypedMessage version: '${version}'`);\n      }\n\n      // Cast to `Hex` here is safe here because `messageParams.from` is not nullish.\n      // `normalize` returns `Hex` unless given a nullish value.\n      const address = normalize(messageParams.from) as Hex;\n      const keyring = (await this.getKeyringForAccount(\n        address,\n      )) as EthKeyring<Json>;\n      if (!keyring.signTypedData) {\n        throw new Error(KeyringControllerError.UnsupportedSignTypedMessage);\n      }\n\n      return await keyring.signTypedData(\n        address,\n        version !== SignTypedDataVersion.V1 &&\n          typeof messageParams.data === 'string'\n          ? JSON.parse(messageParams.data)\n          : messageParams.data,\n        { version },\n      );\n    } catch (error) {\n      throw new Error(`Keyring Controller signTypedMessage: ${error}`);\n    }\n  }\n\n  /**\n   * Signs a transaction by calling down into a specific keyring.\n   *\n   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.\n   * @param from - Address to sign from, should be in keychain.\n   * @param opts - An optional options object.\n   * @returns Promise resolving to a signed transaction string.\n   */\n  async signTransaction(\n    transaction: TypedTransaction,\n    from: string,\n    opts?: Record<string, unknown>,\n  ): Promise<TxData> {\n    const address = normalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signTransaction) {\n      throw new Error(KeyringControllerError.UnsupportedSignTransaction);\n    }\n\n    return await keyring.signTransaction(address, transaction, opts);\n  }\n\n  /**\n   * Convert a base transaction to a base UserOperation.\n   *\n   * @param from - Address of the sender.\n   * @param transactions - Base transactions to include in the UserOperation.\n   * @returns A pseudo-UserOperation that can be used to construct a real.\n   */\n  async prepareUserOperation(\n    from: string,\n    transactions: EthBaseTransaction[],\n  ): Promise<EthBaseUserOperation> {\n    const address = normalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.prepareUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedPrepareUserOperation);\n    }\n\n    return await keyring.prepareUserOperation(address, transactions);\n  }\n\n  /**\n   * Patches properties of a UserOperation. Currently, only the\n   * `paymasterAndData` can be patched.\n   *\n   * @param from - Address of the sender.\n   * @param userOp - UserOperation to patch.\n   * @returns A patch to apply to the UserOperation.\n   */\n  async patchUserOperation(\n    from: string,\n    userOp: EthUserOperation,\n  ): Promise<EthUserOperationPatch> {\n    const address = normalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.patchUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedPatchUserOperation);\n    }\n\n    return await keyring.patchUserOperation(address, userOp);\n  }\n\n  /**\n   * Signs an UserOperation.\n   *\n   * @param from - Address of the sender.\n   * @param userOp - UserOperation to sign.\n   * @returns The signature of the UserOperation.\n   */\n  async signUserOperation(\n    from: string,\n    userOp: EthUserOperation,\n  ): Promise<string> {\n    const address = normalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.signUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedSignUserOperation);\n    }\n\n    return await keyring.signUserOperation(address, userOp);\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given encryption key and salt.\n   *\n   * @param encryptionKey - Key to unlock the keychain.\n   * @param encryptionSalt - Salt to unlock the keychain.\n   * @returns Promise resolving to the current state.\n   */\n  async submitEncryptionKey(\n    encryptionKey: string,\n    encryptionSalt: string,\n  ): Promise<KeyringControllerMemState> {\n    this.#keyrings = await this.#unlockKeyrings(\n      undefined,\n      encryptionKey,\n      encryptionSalt,\n    );\n    this.#setUnlocked();\n\n    const qrKeyring = this.getQRKeyring();\n    if (qrKeyring) {\n      // if there is a QR keyring, we need to subscribe\n      // to its events after unlocking the vault\n      this.#subscribeToQRKeyringEvents(qrKeyring);\n    }\n\n    return this.#getMemState();\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given password.\n   *\n   * @param password - Password to unlock the keychain.\n   * @returns Promise resolving to the current state.\n   */\n  async submitPassword(password: string): Promise<KeyringControllerMemState> {\n    this.#keyrings = await this.#unlockKeyrings(password);\n    this.#setUnlocked();\n\n    const qrKeyring = this.getQRKeyring();\n    if (qrKeyring) {\n      // if there is a QR keyring, we need to subscribe\n      // to its events after unlocking the vault\n      this.#subscribeToQRKeyringEvents(qrKeyring);\n    }\n\n    return this.#getMemState();\n  }\n\n  /**\n   * Verifies the that the seed phrase restores the current keychain's accounts.\n   *\n   * @returns Promise resolving to the seed phrase as Uint8Array.\n   */\n  async verifySeedPhrase(): Promise<Uint8Array> {\n    const primaryKeyring = this.getKeyringsByType(KeyringTypes.hd)[0] as\n      | EthKeyring<Json>\n      | undefined;\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found.');\n    }\n\n    assertHasUint8ArrayMnemonic(primaryKeyring);\n\n    const seedWords = primaryKeyring.mnemonic;\n    const accounts = await primaryKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (accounts.length === 0) {\n      throw new Error('Cannot verify an empty keyring.');\n    }\n\n    // The HD Keyring Builder is a default keyring builder\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const hdKeyringBuilder = this.#getKeyringBuilderForType(KeyringTypes.hd)!;\n\n    const hdKeyring = hdKeyringBuilder();\n    // @ts-expect-error @metamask/eth-hd-keyring correctly handles\n    // Uint8Array seed phrases in the `deserialize` method.\n    await hdKeyring.deserialize({\n      mnemonic: seedWords,\n      numberOfAccounts: accounts.length,\n    });\n    const testAccounts = await hdKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (testAccounts.length !== accounts.length) {\n      throw new Error('Seed phrase imported incorrect number of accounts.');\n    }\n\n    testAccounts.forEach((account: string, i: number) => {\n      /* istanbul ignore if */\n      if (account.toLowerCase() !== accounts[i].toLowerCase()) {\n        throw new Error('Seed phrase imported different accounts.');\n      }\n    });\n\n    return seedWords;\n  }\n\n  // QR Hardware related methods\n\n  /**\n   * Get QR Hardware keyring.\n   *\n   * @returns The QR Keyring if defined, otherwise undefined\n   */\n  getQRKeyring(): QRKeyring | undefined {\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    return this.getKeyringsByType(KeyringTypes.qr)[0] as unknown as QRKeyring;\n  }\n\n  /**\n   * Get QR hardware keyring. If it doesn't exist, add it.\n   *\n   * @returns The added keyring\n   */\n  async getOrAddQRKeyring(): Promise<QRKeyring> {\n    return this.getQRKeyring() || (await this.#addQRKeyring());\n  }\n\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async restoreQRKeyring(serialized: any): Promise<void> {\n    (await this.getOrAddQRKeyring()).deserialize(serialized);\n    await this.persistAllKeyrings();\n  }\n\n  async resetQRKeyringState(): Promise<void> {\n    (await this.getOrAddQRKeyring()).resetStore();\n  }\n\n  async getQRKeyringState(): Promise<IQRKeyringState> {\n    return (await this.getOrAddQRKeyring()).getMemStore();\n  }\n\n  async submitQRCryptoHDKey(cryptoHDKey: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);\n  }\n\n  async submitQRCryptoAccount(cryptoAccount: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);\n  }\n\n  async submitQRSignature(\n    requestId: string,\n    ethSignature: string,\n  ): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);\n  }\n\n  async cancelQRSignRequest(): Promise<void> {\n    (await this.getOrAddQRKeyring()).cancelSignRequest();\n  }\n\n  /**\n   * Cancels qr keyring sync.\n   */\n  async cancelQRSynchronization(): Promise<void> {\n    // eslint-disable-next-line n/no-sync\n    (await this.getOrAddQRKeyring()).cancelSync();\n  }\n\n  async connectQRHardware(\n    page: number,\n  ): Promise<{ balance: string; address: string; index: number }[]> {\n    try {\n      const keyring = await this.getOrAddQRKeyring();\n      let accounts;\n      switch (page) {\n        case -1:\n          accounts = await keyring.getPreviousPage();\n          break;\n        case 1:\n          accounts = await keyring.getNextPage();\n          break;\n        default:\n          accounts = await keyring.getFirstPage();\n      }\n      // TODO: Replace `any` with type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return accounts.map((account: any) => {\n        return {\n          ...account,\n          balance: '0x0',\n        };\n      });\n    } catch (e) {\n      // TODO: Add test case for when keyring throws\n      /* istanbul ignore next */\n      throw new Error(`Unspecified error when connect QR Hardware, ${e}`);\n    }\n  }\n\n  async unlockQRHardwareWalletAccount(index: number): Promise<void> {\n    const keyring = await this.getOrAddQRKeyring();\n\n    keyring.setAccountToUnlock(index);\n    // QRKeyring is not yet compatible with Keyring from\n    // @metamask/utils, but we can use the `addNewAccount` method\n    // as it internally calls `addAccounts` from on the keyring instance,\n    // which is supported by QRKeyring API.\n    await this.addNewAccountForKeyring(keyring as unknown as EthKeyring<Json>);\n    await this.persistAllKeyrings();\n  }\n\n  async getAccountKeyringType(account: string): Promise<string> {\n    const keyring = (await this.getKeyringForAccount(\n      account,\n    )) as EthKeyring<Json>;\n    return keyring.type;\n  }\n\n  async forgetQRDevice(): Promise<{\n    removedAccounts: string[];\n    remainingAccounts: string[];\n  }> {\n    const keyring = await this.getOrAddQRKeyring();\n    const allAccounts = (await this.getAccounts()) as string[];\n    keyring.forgetDevice();\n    const remainingAccounts = (await this.getAccounts()) as string[];\n    const removedAccounts = allAccounts.filter(\n      (address: string) => !remainingAccounts.includes(address),\n    );\n    await this.persistAllKeyrings();\n    return { removedAccounts, remainingAccounts };\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers() {\n    this.messagingSystem.registerActionHandler(\n      `${name}:signMessage`,\n      this.signMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signPersonalMessage`,\n      this.signPersonalMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signTypedMessage`,\n      this.signTypedMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:decryptMessage`,\n      this.decryptMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getEncryptionPublicKey`,\n      this.getEncryptionPublicKey.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getAccounts`,\n      this.getAccounts.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringsByType`,\n      this.getKeyringsByType.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringForAccount`,\n      this.getKeyringForAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:persistAllKeyrings`,\n      this.persistAllKeyrings.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:prepareUserOperation`,\n      this.prepareUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:patchUserOperation`,\n      this.patchUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signUserOperation`,\n      this.signUserOperation.bind(this),\n    );\n  }\n\n  /**\n   * Get the keyring builder for the given `type`.\n   *\n   * @param type - The type of keyring to get the builder for.\n   * @returns The keyring builder, or undefined if none exists.\n   */\n  #getKeyringBuilderForType(\n    type: string,\n  ): { (): EthKeyring<Json>; type: string } | undefined {\n    return this.#keyringBuilders.find(\n      (keyringBuilder) => keyringBuilder.type === type,\n    );\n  }\n\n  /**\n   * Add qr hardware keyring.\n   *\n   * @returns The added keyring\n   * @throws If a QRKeyring builder is not provided\n   * when initializing the controller\n   */\n  async #addQRKeyring(): Promise<QRKeyring> {\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    const qrKeyring = (await this.#newKeyring(KeyringTypes.qr, {\n      accounts: [],\n    })) as unknown as QRKeyring;\n\n    const accounts = await qrKeyring.getAccounts();\n    await this.#checkForDuplicate(KeyringTypes.qr, accounts);\n\n    this.#keyrings.push(qrKeyring as unknown as EthKeyring<Json>);\n    await this.persistAllKeyrings();\n\n    this.#subscribeToQRKeyringEvents(qrKeyring);\n\n    return qrKeyring;\n  }\n\n  /**\n   * Subscribe to a QRKeyring state change events and\n   * forward them through the messaging system.\n   *\n   * @param qrKeyring - The QRKeyring instance to subscribe to\n   */\n  #subscribeToQRKeyringEvents(qrKeyring: QRKeyring) {\n    this.#qrKeyringStateListener = (state) => {\n      this.messagingSystem.publish(`${name}:qrKeyringStateChange`, state);\n    };\n\n    qrKeyring.getMemStore().subscribe(this.#qrKeyringStateListener);\n  }\n\n  #unsubscribeFromQRKeyringsEvents() {\n    const qrKeyrings = this.getKeyringsByType(\n      KeyringTypes.qr,\n    ) as unknown as QRKeyring[];\n\n    qrKeyrings.forEach((qrKeyring) => {\n      if (this.#qrKeyringStateListener) {\n        qrKeyring.getMemStore().unsubscribe(this.#qrKeyringStateListener);\n      }\n    });\n  }\n\n  /**\n   * Create new vault with an initial keyring\n   *\n   * Destroys any old encrypted storage,\n   * creates a new encrypted store with the given password,\n   * creates a new wallet with 1 account.\n   *\n   * @fires KeyringController:unlock\n   * @param password - The password to encrypt the vault with.\n   * @param keyring - A object containing the params to instantiate a new keyring.\n   * @param keyring.type - The keyring type.\n   * @param keyring.opts - Optional parameters required to instantiate the keyring.\n   * @returns A promise that resolves to the state.\n   */\n  async #createNewVaultWithKeyring(\n    password: string,\n    keyring: {\n      type: string;\n      opts?: unknown;\n    },\n  ): Promise<KeyringControllerMemState> {\n    if (typeof password !== 'string') {\n      throw new TypeError(KeyringControllerError.WrongPasswordType);\n    }\n    this.#password = password;\n\n    await this.#clearKeyrings();\n    await this.#createKeyringWithFirstAccount(keyring.type, keyring.opts);\n    this.#setUnlocked();\n    return this.#getMemState();\n  }\n\n  /**\n   * Update the controller state with its current keyrings.\n   */\n  async #updateKeyringsInState(): Promise<void> {\n    const keyrings = await Promise.all(this.#keyrings.map(displayForKeyring));\n    this.update((state) => {\n      state.keyrings = keyrings;\n    });\n  }\n\n  /**\n   * Unlock Keyrings, decrypting the vault and deserializing all\n   * keyrings contained in it, using a password or an encryption key with salt.\n   *\n   * @param password - The keyring controller password.\n   * @param encryptionKey - An exported key string to unlock keyrings with.\n   * @param encryptionSalt - The salt used to encrypt the vault.\n   * @returns A promise resolving to the deserialized keyrings array.\n   */\n  async #unlockKeyrings(\n    password: string | undefined,\n    encryptionKey?: string,\n    encryptionSalt?: string,\n  ): Promise<EthKeyring<Json>[]> {\n    const encryptedVault = this.state.vault;\n    if (!encryptedVault) {\n      throw new Error(KeyringControllerError.VaultError);\n    }\n\n    await this.#clearKeyrings();\n\n    let vault;\n\n    if (this.#cacheEncryptionKey) {\n      assertIsExportableKeyEncryptor(this.#encryptor);\n\n      if (password) {\n        const result = await this.#encryptor.decryptWithDetail(\n          password,\n          encryptedVault,\n        );\n        vault = result.vault;\n        this.#password = password;\n\n        this.update((state) => {\n          state.encryptionKey = result.exportedKeyString;\n          state.encryptionSalt = result.salt;\n        });\n      } else {\n        const parsedEncryptedVault = JSON.parse(encryptedVault);\n\n        if (encryptionSalt !== parsedEncryptedVault.salt) {\n          throw new Error(KeyringControllerError.ExpiredCredentials);\n        }\n\n        if (typeof encryptionKey !== 'string') {\n          throw new TypeError(KeyringControllerError.WrongPasswordType);\n        }\n\n        const key = await this.#encryptor.importKey(encryptionKey);\n        vault = await this.#encryptor.decryptWithKey(key, parsedEncryptedVault);\n\n        // This call is required on the first call because encryptionKey\n        // is not yet inside the memStore\n        this.update((state) => {\n          state.encryptionKey = encryptionKey;\n          // we can safely assume that encryptionSalt is defined here\n          // because we compare it with the salt from the vault\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          state.encryptionSalt = encryptionSalt!;\n        });\n      }\n    } else {\n      if (typeof password !== 'string') {\n        throw new TypeError(KeyringControllerError.WrongPasswordType);\n      }\n\n      vault = await this.#encryptor.decrypt(password, encryptedVault);\n      this.#password = password;\n    }\n\n    if (!isSerializedKeyringsArray(vault)) {\n      throw new Error(KeyringControllerError.VaultDataError);\n    }\n\n    await Promise.all(vault.map(this.#restoreKeyring.bind(this)));\n    await this.#updateKeyringsInState();\n\n    if (\n      this.#password &&\n      (!this.#cacheEncryptionKey || !encryptionKey) &&\n      this.#encryptor.isVaultUpdated &&\n      !this.#encryptor.isVaultUpdated(encryptedVault)\n    ) {\n      // Re-encrypt the vault with safer method if one is available\n      await this.persistAllKeyrings();\n    }\n\n    return this.#keyrings;\n  }\n\n  /**\n   * Create a new keyring, ensuring that the first account is\n   * also created.\n   *\n   * @param type - Keyring type to instantiate.\n   * @param opts - Optional parameters required to instantiate the keyring.\n   * @returns A promise that resolves if the operation is successful.\n   */\n  async #createKeyringWithFirstAccount(type: string, opts?: unknown) {\n    const keyring = (await this.addNewKeyring(type, opts)) as EthKeyring<Json>;\n\n    const [firstAccount] = await keyring.getAccounts();\n    if (!firstAccount) {\n      throw new Error(KeyringControllerError.NoFirstAccount);\n    }\n  }\n\n  /**\n   * Instantiate, initialize and return a new keyring of the given `type`,\n   * using the given `opts`. The keyring is built using the keyring builder\n   * registered for the given `type`.\n   *\n   * @param type - The type of keyring to add.\n   * @param data - The data to restore a previously serialized keyring.\n   * @returns The new keyring.\n   */\n  async #newKeyring(type: string, data: unknown): Promise<EthKeyring<Json>> {\n    const keyringBuilder = this.#getKeyringBuilderForType(type);\n\n    if (!keyringBuilder) {\n      throw new Error(\n        `${KeyringControllerError.NoKeyringBuilder}. Keyring type: ${type}`,\n      );\n    }\n\n    const keyring = keyringBuilder();\n\n    // @ts-expect-error Enforce data type after updating clients\n    await keyring.deserialize(data);\n\n    if (keyring.init) {\n      await keyring.init();\n    }\n\n    return keyring;\n  }\n\n  /**\n   * Remove all managed keyrings, destroying all their\n   * instances in memory.\n   */\n  async #clearKeyrings() {\n    for (const keyring of this.#keyrings) {\n      await this.#destroyKeyring(keyring);\n    }\n    this.#keyrings = [];\n    this.update((state) => {\n      state.keyrings = [];\n    });\n  }\n\n  /**\n   * Restore a Keyring from a provided serialized payload.\n   * On success, returns the resulting keyring instance.\n   *\n   * @param serialized - The serialized keyring.\n   * @returns The deserialized keyring or undefined if the keyring type is unsupported.\n   */\n  async #restoreKeyring(\n    serialized: SerializedKeyring,\n  ): Promise<EthKeyring<Json> | undefined> {\n    try {\n      const { type, data } = serialized;\n      const keyring = await this.#newKeyring(type, data);\n\n      // getAccounts also validates the accounts for some keyrings\n      await keyring.getAccounts();\n      this.#keyrings.push(keyring);\n\n      return keyring;\n    } catch (_) {\n      this.#unsupportedKeyrings.push(serialized);\n      return undefined;\n    }\n  }\n\n  /**\n   * Destroy Keyring\n   *\n   * Some keyrings support a method called `destroy`, that destroys the\n   * keyring along with removing all its event listeners and, in some cases,\n   * clears the keyring bridge iframe from the DOM.\n   *\n   * @param keyring - The keyring to destroy.\n   */\n  async #destroyKeyring(keyring: EthKeyring<Json>) {\n    await keyring.destroy?.();\n  }\n\n  /**\n   * Remove empty keyrings.\n   *\n   * Loops through the keyrings and removes the ones with empty accounts\n   * (usually after removing the last / only account) from a keyring.\n   */\n  async #removeEmptyKeyrings(): Promise<void> {\n    const validKeyrings: EthKeyring<Json>[] = [];\n\n    // Since getAccounts returns a Promise\n    // We need to wait to hear back form each keyring\n    // in order to decide which ones are now valid (accounts.length > 0)\n\n    await Promise.all(\n      this.#keyrings.map(async (keyring: EthKeyring<Json>) => {\n        const accounts = await keyring.getAccounts();\n        if (accounts.length > 0) {\n          validKeyrings.push(keyring);\n        } else {\n          await this.#destroyKeyring(keyring);\n        }\n      }),\n    );\n    this.#keyrings = validKeyrings;\n  }\n\n  /**\n   * Checks for duplicate keypairs, using the the first account in the given\n   * array. Rejects if a duplicate is found.\n   *\n   * Only supports 'Simple Key Pair'.\n   *\n   * @param type - The key pair type to check for.\n   * @param newAccountArray - Array of new accounts.\n   * @returns The account, if no duplicate is found.\n   */\n  async #checkForDuplicate(\n    type: string,\n    newAccountArray: string[],\n  ): Promise<string[]> {\n    const accounts = await this.getAccounts();\n\n    switch (type) {\n      case KeyringTypes.simple: {\n        const isIncluded = Boolean(\n          accounts.find(\n            (key) =>\n              newAccountArray[0] &&\n              (key === newAccountArray[0] ||\n                key === remove0x(newAccountArray[0])),\n          ),\n        );\n\n        if (isIncluded) {\n          throw new Error(KeyringControllerError.DuplicatedAccount);\n        }\n        return newAccountArray;\n      }\n\n      default: {\n        return newAccountArray;\n      }\n    }\n  }\n\n  /**\n   * Set the `isUnlocked` to true and notify listeners\n   * through the messenger.\n   *\n   * @fires KeyringController:unlock\n   */\n  #setUnlocked(): void {\n    this.update((state) => {\n      state.isUnlocked = true;\n    });\n    this.messagingSystem.publish(`${name}:unlock`);\n  }\n\n  #getMemState(): KeyringControllerMemState {\n    return {\n      isUnlocked: this.state.isUnlocked,\n      keyrings: this.state.keyrings,\n    };\n  }\n}\n\nexport default KeyringController;\n"]}